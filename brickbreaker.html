<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Brickbreaker</title>
  </head>
  <body>
    <canvas id="gameCanvas" height="500px" width="400" > </canvas>
      <script type="text/javascript">
        const gameCanvas = document.getElementById("gameCanvas")
        const context = gameCanvas.getContext("2d")

        //Constants
        const CANVAS_BORDER_COLOR = 'black';
        const CANVAS_BACKGROUND_COLOR = "white";
        const BALL_COLOR = 'red';
        const BALL_BORDER_COLOR = 'black';
        const BLOCK_COLOR = 'black';
        const BLOCK_BORDER_COLOR = 'black';

        const width = gameCanvas.width, height = gameCanvas.height, radius = 7
        let x = gameCanvas.width/2, y = (gameCanvas.height - radius), dx=10, dy=-10
        let duringLevel = false
        let blockArray = [];
        for (let i=0; i < 10; i++){
          blockArray.push([0, 0, 0, 0, 0, 0, 0, 0])
        }

        const refreshXandY = () => {
          x = width/2
          y = (height - radius)
          duringLevel = false
        }

        const newBlocks = () => { //create 2d array to track blocks
          blockArray.unshift(blockArray[0].map(block => Math.random() > .6 ? 1 : 0))
          blockArray.pop()
        }

        //draws the entire block array by looping through. O(n2)
        const drawBlocks = () => {
          blockArray.forEach((blockRow, vertical) => {
            blockRow.forEach((block, horizontal) => {
            if (block === 1) {
              context.fillRect(width/8*horizontal, height/10*(vertical + 1), width/8, height/10)
              context.strokeRect(width/8*horizontal, height/10*(vertical + 1), width/8, height/10)
            }
            })
          })
        }



        const drawInitialBoard = () => {
          context.fillStyle = CANVAS_BACKGROUND_COLOR; context.strokestyle = CANVAS_BORDER_COLOR;
          context.fillRect(0, 0, width, height); //board itself
          context.strokeRect(0, 0, width, height);
          context.fillStyle = BALL_COLOR
          context.arc(width/2,height - radius,7,0,Math.PI*2,true); //ball
          context.fill()
          drawBlocks()
        }

        const moveBall = () => {
          if (y > height - radius){ //only way to end a level
            nextLevel()
            return
          }
          if (x < radius || x > width - radius) { dx = -dx } //collision logic
          if (y < radius || y > height - radius) { dy = -dy }
          for (let i = 0; i<10; i++){ // yikes on this nested for loop. need to rework
            for (let j = 0; j<8; j++){
              if (blockArray[i][j] === 1){
                const blockXLeft = width/8*j; const blockYTop = height/10*(i+1)
                const blockXRight = width/8*j + width/8 ; const blockYBottom = height/10*(i+1) + height/10
                const roundX = Math.round(x); roundY = Math.round(y)
                if ((blockXLeft <= x && x <= blockXRight) && (blockYTop <= y && y <= blockYBottom)){
                  blockArray[i][j] = 0 // delete block that is detected as hit

                  //determine if a horizonal or vertical collision
                  if (Math.abs(roundX - blockXLeft) < 5 || Math.abs(roundX - blockXRight) < 5) {
                    dx = -dx //change direction
                  } else {
                    dy = -dy
                  }
                }
                // if ((blockX <= x && x <= blockX + width/8) && (blockY <= y && y <= blockY + height/10)){
                //   blockArray[i][j] = 0 // delete block that is detected as hit
                //   console.log(roundX, roundY, blockX, blockX+width/8, blockY, blockY + height/10)
                //   dy = -dy //change direction
                // }
                }
              }
            }
          x += dx; y += dy
          context.clearRect(0, 0, width, height)
          context.strokeRect(0, 0, width, height);
          context.beginPath()
          context.arc(x,y,radius,0,Math.PI*2,true);
          context.closePath()
          context.fill()
          drawBlocks()
          main()
        }

        const nextLevel = () => {
          refreshXandY()
          newBlocks()
        }

        const buildUnitVector = (x0, y0, x1, y1) => { //todo
          let netX = x1 - x0; let netY = y1 - y0
          let magnitude = Math.sqrt( Math.pow(netX, 2) + Math.pow(netY, 2))
          return {unitX: netX/magnitude, unitY: netY/magnitude, mag: magnitude}
        }

        const handleMouseMove = event => {
          if (!duringLevel) {
            const {clientX, clientY} = event
            context.clearRect(0, 0, width, height); drawInitialBoard()//maintain the initial board set up
            context.beginPath()
            context.moveTo(x, y)
            context.lineTo(clientX, clientY)
            context.stroke()
            context.closePath()
          }
        }

        const handleMouseClick = event => {
          if (!duringLevel) {
            const {clientX, clientY} = event
            const {unitX, unitY} = buildUnitVector(x, y, clientX, clientY)
            dx = unitX * 1.5; dy = unitY * 1.5;
            main()
          }
        }

        const main = () => {
          duringLevel = true
          setTimeout(moveBall, 1)
        }

        gameCanvas.addEventListener("mousemove", handleMouseMove)
        gameCanvas.addEventListener("click", handleMouseClick)
        newBlocks()
        drawInitialBoard()

      </script>
  </body>
</html>
